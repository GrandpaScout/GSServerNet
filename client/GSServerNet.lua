-- ┌───┐                ┌───┐ --
-- │ ┌─┘ ┌─────┐┌─────┐ └─┐ │ --
-- │ │   │ ┌───┘│ ╶───┤   │ │ --
-- │ │   │ ├───┐└───┐ │   │ │ --
-- │ │   │ └─╴ │┌───┘ │   │ │ --
-- │ └─┐ └─────┘└─────┘ ┌─┘ │ --
-- └───┘                └───┘ --
---@module  "ServerNet Library" <GSServerNet>
---@version v1.1.2
---@see     GrandpaScout @ https://github.com/GrandpaScout
-- Allows communication between the server and a Figura user.
-- ServerNet clients can receive messages containing any amount of values from the server
-- and send messages containing a single integer value to the server.
--
-- This is handled by a datapack on the server that can send and receive ServerNet messages.

--]] =======================================================================
--]] ⚠ DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT EDITING THIS FILE DOES! ⚠
--]]
--]] You have no reason to be modifying this file unless you know how to
--]] modify library files.
--]] (Spoiler alert, *you very likely do not.*)
--]]
--]] If you wish to access the features of this library, use Lua's `require`
--]] system in a different script file to get access to this library's
--]] contents.
--]]
--]]     local SVNet = require("GSServerNet")
--]]
--]] ⚠ DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT EDITING THIS FILE DOES! ⚠
--]] =======================================================================

local ID = "GSServerNet"
local VER = "1.1.2"
local FIG = {"0.1.2", "0.1.2"}

local PROTOCOL = 1


---===|| LOCALS ||===================================================================================================---

local insert = table.insert
local remove = table.remove
local lang = client.getTranslatedString

local HOST = host:isHost()

local INF = math.huge
local NAN = 0 / 0

---@type string, string
local PATH, FILE = ...
local FULL_PATH = PATH ~= "" and (PATH .. "." .. FILE) or FILE


---===|| LIB SETUP ||================================================================================================---

---Allows communication between a Figura user and the Minecraft server they are on.
---
---&nbsp;  
---The first step of connecting is to require this library as soon as possible and create receivers for messages this
---avatar will receive from the server.
---```lua
---local SVNet = require("GSServerNet")
---
---SVNet.receive("message_name", function(name, param1, param2, paramN, ...)
---  -- Do something here with the message.
---end)
---```
---
---If you plan to send messages to the server, it is a good idea to wait for ServerNet to confirm that the server will
---accept messages, otherwise you will get errors.
---```lua
---local should_send = false
---
---SVNet.await(function(success)
---  if success then should_send = true end
---end)
---
---local kb_rj = keybinds:newKeybind("Rocket Jump", "key.keyboard.g")
---kb_rj:onPress(function()
---  if should_send then SVNet.send("rocketjump"):onError() end
---end)
---```
---
---ServerNet messages are *not* pinged as there are too many ways to go about doing it.  
---Find the method of syncing messages that suits your needs most.
---
---The only part of ServerNet that is pinged automatically is the ServerNet connection status.
---
---&nbsp;  
---### If you wish to learn more about the server-side of ServerNet,
---### see the README file in the datapack provided with this library.
---@class Lib.GS.ServerNet
---This library's perferred ID.
---@field _ID string
---This library's version.
---@field _VERSION string
local this = {
  ---Contains the names of messages that the server defines.
  ---
  ---Messages that the client (the Figura avatar) receives from the server are defined in `.receive`.  
  ---Messages that the client can send to the server are defined in `.send`.
  registry = {
    ---Contains the names of messages that the client receives from the server.
    ---
    ---Indexing by a number will return the name of the message at that index.  
    ---Indexing with the name of a message will return `true` if it exists.
    ---@type {[number]: string, [string]: true}
    receive = {},

    ---Contains the names of messages the client can send to the server.
    ---
    ---Indexing by a number will return the name of the message at that index.  
    ---Indexing with the name of a message will return `true` if it exists.
    ---@type {[number]: string, [string]: true}
    send = {}
  },

  ---Enable logging of svnet messages.
  ---
  ---Logs with `>>` are being sent to the server, logs with `<<` are being received from the server.
  log = false,

  ---Disable warning messages.
  suppress_warnings = false,

  ---Controls how long a message should wait in ticks before assuming the message should just resolve.  
  ---If you are seeing error or success messages from the server in chat then this number is too low.
  ---
  ---`timeout_errors` controls if a timeout causes messages to error.
  ---@type integer
  timeout = 5,

  ---Determines if messages should error if they time out.
  ---
  ---The default is to let messages to succeed as the only vanilla reason that a message would time out is if the
  ---success message was blocked by `sendCommandFeedback`.
  ---@type boolean
  timeout_errors = false,

  ---### Debug value
  ---Enable usage of the `svnet:_echo_` message type. If this is used, it *must* be the first component in a JSON array
  ---or the root component if using the `"extra"` tag. This breaks the rules that every other message type follows to
  ---avoid its accidental usage.
  ---
  ---This is disabled by default as it is only useful for debugging.
  ---@type boolean
  allow_echo = false,

  ---### Debug value
  ---Causes this library to print the contents of *every* chat message the client receives.  
  ---Does not print the contents of Lua prints to avoid endless loops.
  ---@type boolean
  echo_all = false
}

local thismt = {
  __type = ID,
  __metatable = false,
  __index = {
    _ID = ID,
    _VERSION = VER
  }
}


---===|| LOGGING ||==================================================================================================---

local colors = {
  ["nil"] = "#FF5555",
  boolean = "#A155DA",
  number = "#00F0FF",
  string = "white",
  table = "#5EA5FF",
  ["function"] = "green",
  thread = "gold",
  userdata = "yellow"
}

local log_value = [[{"text": %s, "color": "%s"}]]

local function svnet_logs(msg, value)
  printJson(([=[[
    "",
    {"text": "[svnet] ", "color": "#FFAA55"},
    "%s",
    {"text": " : ", "color": "#FFAA55"},
    "%s",
    {"text": " >> ", "color": "#FFAA55"},
    {"text": "%s\n", "color": "#00F0FF"}
  ]]=]):format(avatar:getEntityName(), msg, value or ""))
end

local function svnet_logr(msg, params, n)
  local paramstrs = {}
  for i = 1, n do
    local param = params[i]
    paramstrs[i] = log_value:format(
      toJson(printTable(param, 0, true)),
      colors[type(param)] or colors.userdata
    )
  end

  printJson(([=[[
    "",
    {"text": "[svnet] ", "color": "#FFAA55"},
    "%s",
    {"text": " : ", "color": "#FFAA55"},
    "%s",
    {"text": " << ", "color": "#FFAA55"},
    %s, "\n"
  ]]=]):format(avatar:getEntityName(), msg, table.concat(paramstrs, ", \"  \", ")))
end


---===|| AWAIT ||====================================================================================================---

local awaiting_response = {}
local awaiting_registry = {}
local server_responded
local server_gotregistry

---Prepares a callback to run when ServerNet determines if the server accepts messages.  
---This can be used multiple times to prepare multiple callbacks.
---
---**It is possible for this function to run *after* `.awaitRegistry()`!**
---
---The function will be given `true` if the server accepts svnet messages, `false` if not.
---@param func fun(success: boolean)
function this.await(func)
  if not HOST then return end
  if type(func) ~= "function" then
    error("bad argument #1 to 'await' (expected function, got " .. type(func) .. ")", 2)
  end

  if server_responded ~= nil then
    func(server_responded)
  else
    awaiting_response[#awaiting_response+1] = func
  end
end

---Prepares a callback to run when ServerNet gets the server's registry.  
---This can be used multiple times to prepare multiple callbacks.
---
---**It is possible for ServerNet to get the registry before it can determine if the server accepts messages!**  
---This will cause the callbacks put in this function to run before the callbacks put into `.await()` run.
---
---If the server does not accept svnet messages, the function will be given `false`.
---@param func fun(registry: {receive: {[number]: string, [string]: true}, send: {[number]: string, [string]: true}} | false)
function this.awaitRegistry(func)
  if not HOST then return end
  if type(func) ~= "function" then
    error("bad argument #1 to 'awaitRegistry' (expected function, got " .. type(func) .. ")", 2)
  end

  if server_gotregistry ~= nil then
    func(server_gotregistry and this.registry)
  else
    awaiting_registry[#awaiting_registry+1] = func
  end
end


---===|| RECEIVER ||=================================================================================================---

---@alias Lib.GS.ServerNet.value
---| nil                                                # `svnet:nil`
---| boolean                                            # `svnet:boolean`
---| number                                             # `svnet:number`
---| string                                             # `svnet:string`
---| Lib.GS.ServerNet.value[]                           # `svnet:array`
---| {[Lib.GS.ServerNet.value]: Lib.GS.ServerNet.value} # `svnet:keyvalue`
---| Entity.any                                         # `svnet:selector`

---A receiver is `false` if it didn't exist when the server expected it. Used in error handling.
---@type {[string]: false | fun(msg: string, ...: Lib.GS.ServerNet.value)}
local net_receivers = {
  -- This exists to stop servers from adding _echo_ to their registry to force a warning message.
  -- This is never used normally because `_echo_` is handled internally.
  _echo_ = function() end
}

---Do not allow receivers to be made with any names found in this set.
---
---Logging functions will also avoid logging any messages found in here.
local forbidden_receivers = {
  _registry_ = true,
  _echo_ = true
}

---Registers the message with the given name.
---
---The given callback is run every time the message is recieved.
---@param message string
---@param callback fun(msg: string, ...: Lib.GS.ServerNet.value)
function this.receive(message, callback)
  if not HOST then return end
  if type(message) ~= "string" then
    error("bad argument #1 to 'receive' (expected string, got " .. type(message) .. ")", 2)
  else
    message = message:gsub("^svnet:", "")
    if forbidden_receivers[message] then
      error("receiver name of '" .. message .. "' is forbidden", 2)
    elseif not message:match("^[%w_./-]+$") then
      error("invalid receiver name '" .. message .. "'", 2)
    end
  end
  if callback and type(callback) ~= "function" then
    error("bad argument #2 to 'receive' (expected function, got " .. type(callback) .. ")", 2)
  end

  net_receivers[message] = callback
end


---===|| PROMISE ||==================================================================================================---

---@class Lib.GS.ServerNet.Message
---The name of this message.
---@field name string
---The time this message was sent.
---@field time integer
---The error that this message received.
---@field err? string
---Whether this message has gotten a response yet.
---@field resolved boolean
---Which action to take when this message times out.  
---`true` to succeed, `false` to error.
---
---If this is `nil`, the default action will be taken.
---@field timeout_action? boolean
---The function that runs when this message is sent successfully.
---@field package success fun(message: string)
---The function that runs when this message fails to send.
---@field package error fun(message: string, reason: string)
local Message = {}
local MessageMT = {
  __index = Message,
  __type = "ServerNetMessage"
}

---Sets the function that should run if this message is successful.
---
---If this is used after the message succeeds, it runs the callback instantly.
---@generic self
---@param self self
---@param callback? fun(message: string)
---@return self
function Message:onSuccess(callback)
  ---@cast self Lib.GS.ServerNet.Message
  if callback and type(callback) ~= "function" then
    error("bad argument #2 to 'onSuccess' (expected function, got " .. type(callback) .. ")", 2)
  end

  self.success = callback
  if self.resolved and not self.err and callback then callback(self.name) end
  return self
end

---Sets the function that should run if this message fails.  
---The reason for failure is given.
---
---If this is used after the message fails, it runs the callback instantly.
---@generic self
---@param self self
---@param callback? fun(message: string, reason: string)
---@return self
function Message:onError(callback)
  ---@cast self Lib.GS.ServerNet.Message
  if callback and type(callback) ~= "function" then
    error("bad argument #2 to 'onError' (expected function, got " .. type(callback) .. ")", 2)
  end

  self.error = callback
  if self.resolved and self.err and callback then callback(self.name, self.err) end
  return self
end


---===|| TRANSMITTER ||==============================================================================================---

---@type Lib.GS.ServerNet.Message[]
local trigger_queue = {}
local trigger_cmd = [[trigger svnet.%s set %d]]

---Do not allow messages to be sent with any names found in this set.
---
---Logging functions will also avoid logging any messages found in here.
local forbidden_messages = {
  _start_ = true
}

---@type fun(message: string, reason: string)
local function unhandled_error(message, reason)
  if this.suppress_warnings then return end
  printJson(([=[[
    "",
    {"text":"[warning] ", "color":"#FFDD55"},
    "%s",
    {"text":" : unhandled error in message '%s':\n  %s\n", "color":"#FFDD55"}
  ]]=]):format(avatar:getEntityName(), message, reason))
end

---Sends a message to the server.
---
---This returns a Promise-like value that will run a callback depending on if the message was successful or not.
---
---By default, all messages contain an error handler that will report the error sent through the message.  
---To disable this, use `:onError()` with no function to acknowledge that you don't want an error to be reported.
---
---If the server sets the `sendCommandFeedback` gamerule to `false`, this function creates *unreliable messages*.  
---There is no guarantee that these will succeed and may instead time out.  
---The amount of time it takes for a message to time out can be configured at `<GSServerNet>.timeout`.
---
---If `value` is `nil`, it will default to `1`.
---@param message string
---@param value? integer
---@return Lib.GS.ServerNet.Message
function this.send(message, value)
  if not HOST then
    -- This object is only here to avoid dumb errors.
    return (setmetatable({
      name = message,
      resolved = false,
      time = world.getTime(),
      error = unhandled_error
    }, MessageMT))
  end
  if not server_responded then
    if server_responded == nil then error("connection to servernet has not been made yet", 2) end
    error("server does not accept servernet messages", 2)
  end
  if type(message) ~= "string" then
    error("bad argument #1 to 'send' (string expected, got " .. type(message) .. ")", 2)
  else
    message = message:gsub("^svnet[.:]", "")
    if forbidden_messages[message] then
      error("message name of '" .. message .. "' is forbidden", 2)
    elseif not message:match("^[%w_.+-][%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?$") then
      error("invalid message name '" .. message .. "'", 2)
    end
  end

  if value and type(value) ~= "number" then
    error("bad argument #2 to 'send' (integer expected, got " .. type(value) .. ")", 2)
  elseif value and (value >= 0x80000000 or value < -0x80000000) then
    error("bad argument #2 to 'send' (value out of range)", 2)
  end

  local obj = {
    name = message,
    resolved = false,
    time = world.getTime(),
    error = unhandled_error
  }

  host:sendChatCommand(trigger_cmd:format(message, value or 1))
  if this.log then svnet_logs(message, value and math.floor(value)) end

  insert(trigger_queue, obj)
  return (setmetatable(obj, MessageMT))
end


---===|| CHAT HANDLER ||=============================================================================================---

---Strings that should be considered false.
local svnet_falsey = {
  ["false"] = true, ["nil"] = true,
  [""] = true,
  ["0"] = true, ["0.0"] = true, ["-0"] = true, ["-0.0"] = true,
  nan = true, NaN = true, NAN = true, qnan = true, qNaN = true, QNAN = true,
  ["0b"] = true, ["0s"] = true, ["0L"] = true, ["0.0f"] = true, ["0.0d"] = true,
  null = true
}

---Strings `tonumber()` cannot convert that should be converted into numbers anyways.
local svnet_number = {
  ["false"] = 0, ["true"] = 1,
  inf = INF, INF = INF,
  infinity = INF, Infinity = INF,
  ["-inf"] = -INF, ["-INF"] = -INF,
  ["-infinity"] = -INF, ["-Infinity"] = -INF,
  nan = NAN, NaN = NAN, NAN = NAN,
  qnan = -NAN, qNaN = -NAN, QNAN = -NAN,
  ["-nan"] = -NAN, ["-NaN"] = -NAN, ["-NAN"] = -NAN,
  ["-qnan"] = NAN, ["-qNaN"] = NAN, ["-QNAN"] = NAN
}

local function read_adv_param(param)
  if not param then return end
  if type(param) == "string" then
    if param ~= "" then
      if param:match("^%.") then
        return param:sub(2)
      elseif param == "true" or param == "false" then
        return param == "true"
      elseif param ~= "nil" and param ~= "null" then
        return tonumber(param) or param
      end
    end
  else
    local text = param.text
    if param.translate then
      local tl = param.translate
      local with = {}
      if param.with then
        for j, v in ipairs(param.with) do with[j] = toJson(v) end
      end
      text = lang(tl, with)
      if text == tl and param.fallback then text = param.fallback end
    elseif param.keybind then
      local key = keybinds:getVanillaKey(param.keybind)
      if key:match("^key%.mouse%.%d+$") then
        text = lang("key.mouse", key:match("^key%.mouse%.(%d+)$"))
      else
        text = lang(key)
      end
    end

    local font = param.font
    if font then
      if font == "svnet:nil" then
        return nil
      elseif font == "svnet:boolean" then
        return not (svnet_falsey[text] or tonumber(text) == 0)
      elseif font == "svnet:number" then
        text = text:gsub("^(%-?%d+)[BbSsLl]$", "%1"):gsub("^(%-?%d+%.?%d*)[FfDd]$", "%1")
        return svnet_number[text] or tonumber(text) or NAN
      elseif font == "svnet:string" then
        return text
      elseif font == "svnet:array" then
        local arr = {}
        if param.extra then
          for i, v in ipairs(param.extra) do arr[i] = read_adv_param(v) end
        end
        if text ~= "" then
          if text:match("^%.") then
            insert(arr, 1, text:sub(2))
          elseif text == "true" or text == "false" then
            insert(arr, 1, text == "true")
          elseif text ~= "nil" and text ~= "null" then
            insert(arr, 1, tonumber(text) or text)
          else
            insert(arr, 1, nil)
          end
        end
        return arr
      elseif font == "svnet:keyvalue" then
        local tbl = {}
        local extra = param.extra
        if extra then
          for i = 1, #extra, 2 do
            local key = read_adv_param(extra[i])
            if key ~= nil then tbl[key] = read_adv_param(extra[i + 1]) end
          end
        end
        return tbl
      elseif font == "svnet:vector" then
        local arr = {}
        if param.extra then
          local value
          for i, v in ipairs(param.extra) do
            value = read_adv_param(v)
            if type(value) == "string" then
              value = value:gsub("^(%-?%d+)[BbSsLl]$", "%1"):gsub("^(%-?%d+%.?%d*)[FfDd]$", "%1")
              arr[i] = svnet_number[value] or tonumber(value) or NAN
            else
              arr[i] = tonumber(value) or NAN
            end
          end
        end
        if text ~= "" then
          text = text:gsub("^(%-?%d+)[BbSsLl]$", "%1"):gsub("^(%-?%d+%.?%d*)[FfDd]$", "%1")
          insert(arr, 1, svnet_number[text] or tonumber(text) or NAN)
        end

        if #arr == 0 then -- Empty vector
          return nil
        elseif #arr == 1 then -- Single number
          return arr[1]
        elseif #arr <= 4 then -- Normal vector
          return vec(table.unpack(arr))
        elseif #arr == 6 then -- Bounding Box
          return {vec(table.unpack(arr, 1, 3)), vec(table.unpack(arr, 4, 6))}
        else -- Undefined vector type
          return arr
        end
      elseif font == "svnet:selector" then
        local ev = param.hoverEvent
        if ev then
          if ev.action == "show_entity" then
            return world.getEntity(ev.contents.id) or ev.contents.id
          end
        elseif param.extra then
          local ents = {}
          local extra = param.extra
          local ent
          for j = 1, #extra, 2 do
            ent = extra[j]
            if not ent then break end
            ev = ent.hoverEvent
            if ev and ev.action == "show_entity" then
              ents[#ents+1] = world.getEntity(ev.contents.id) or ev.contents.id
            end
          end

          return ents
        end
      end
    else
      if text ~= "" then
        if text:match("^%.") then
          return text:sub(2)
        elseif text == "true" or text == "false" then
          return text == "true"
        elseif text ~= "nil" and text ~= "null" then
          return tonumber(text) or text
        end
      end
    end
  end
end

if HOST then
  events.CHAT_RECEIVE_MESSAGE:register(function(text, json)
    local tbl = parseJson(json) --[[@as table]]
    if this.echo_all and not text:match("%[lua%]") then printTable(tbl, 99) end

    -- Handles the responses to trigger commands made by this script when sending messages to the server to avoid
    -- spamming the player's chat.
    if #trigger_queue > 0 then
      if tbl.translate == "commands.trigger.set.success" then
        local msg = trigger_queue[1]
        if msg.success then msg.success(msg.name) end
        msg.resolved = true
        remove(trigger_queue, 1)
        return false
      elseif tbl.text == "" and tbl.color == "red" and tbl.extra then
        local err = tbl.extra[1].translate
        if err == "command.unknown.command" then
          return false
        elseif err == "commands.trigger.failed.unprimed" then
          local msg = trigger_queue[1]
          if msg.error then msg.error(msg.name, "server refused message") end
          msg.resolved = true
          msg.err = "server refused message"
          remove(trigger_queue, 1)
          return false
        elseif err == "arguments.objective.notFound" then
          local msg = trigger_queue[1]
          if msg.error then msg.error(msg.name, "message does not exist on server") end
          msg.resolved = true
          msg.err = "message does not exist on server"
          remove(trigger_queue, 1)
          return false
        else
          local ex = tbl.extra[1].extra
          if ex
            and ex[3]
            and ex[3].translate == "command.context.here"
            and (ex[2].text or ""):match("^trigger [%w_.+-]+ set %-?%d+$")
          then
            local msg = trigger_queue[1]
            if msg.error then msg.error(msg.name, "insufficient permissions to send messages") end
            msg.resolved = true
            msg.err = "insufficient permissions to send messages"
            remove(trigger_queue, 1)
            return false
          end
        end
      end
    end

    -- Remove admin messages that may be caused by this library.
    if tbl.translate == "chat.type.admin" and tbl.with then
      local msg = tbl.with[2]
      if msg and msg.translate == "commands.trigger.set.success" and msg.with and msg.with[1] then
        msg = msg.with[1].text
        if msg and msg:match("^svnet.") then return false end
      end
    end

    if tbl.font == "svnet:_echo_" and this.allow_echo then
      printTable(tbl, 99)
      return false
    end

    local found = false

    ---@type {text?: string, translate?: string, with?: (string | table)[], font: string, fallback?: string, keybind?: string}[]
    local cmps = {}
    if tbl.extra then
      for _, cmp in ipairs(tbl.extra) do
        if (cmp.text == "" or (cmp.translate == "" and not cmp.fallback)) and cmp.font and not cmp.extra then
          insert(cmps, cmp)
        end
      end
    elseif (tbl.text == "" or (tbl.translate == "" and not tbl.fallback)) and tbl.font then
      cmps[1] = tbl
    end

    for _, cmp in ipairs(cmps) do
      ---@type string, string
      local msg, paramstr = cmp.font:match("^svnet:([^/]*)(.*)$")

      if msg then
        if cmp.text then -- Simple version, uses `"font": "svnet:msg_name/param1/param2/paramN"`
          found = true
          local receiver = net_receivers[msg]
          if receiver then
            if paramstr == "" then
              if this.log and not forbidden_receivers[msg] then svnet_logr(msg) end
              receiver(msg)
            else
              local params = {}
              local n_params = 0
              for param in paramstr:gmatch("/([^/]*)") do
                n_params = n_params + 1
                if param ~= "" then
                  if param:match("^%.") then
                    params[n_params] = param:sub(2)
                  elseif param == "true" or param == "false" then
                    params[n_params] = param == "true"
                  elseif param ~= "nil" and param ~= "null" then
                    params[n_params] = tonumber(param) or param
                  end
                end
              end

              if this.log and not forbidden_receivers[msg] then svnet_logr(msg, params, n_params) end
              receiver(msg, table.unpack(params, 1, n_params))
            end
          elseif receiver == nil then
            net_receivers[msg] = false
            if not this.suppress_warnings then
              printJson(([=[[
                "",
                {"text":"[warning] ", "color":"#FFDD55"},
                "%s",
                {"text":" : server attempted to send message '%s', but it is not in the registry\n", "color":"#FFDD55"}
              ]]=]):format(avatar:getEntityName(), msg))
            end
          end
        elseif cmp.translate then -- Advanced version, uses `"with": [{param1}, {param2}, {paramN}]`
          found = true
          msg = msg .. paramstr
          local receiver = net_receivers[msg]
          if receiver then
            if not cmp.with then
              if this.log and not forbidden_receivers[msg] then svnet_logr(msg) end
              receiver(msg)
            else
              local params = {}
              local n_params = #cmp.with
              for i, param in ipairs(cmp.with) do
                params[i] = read_adv_param(param)
              end

              if this.log and not forbidden_receivers[msg] then svnet_logr(msg, params, n_params) end
              receiver(msg, table.unpack(params, 1, n_params))
            end
          elseif receiver == nil then
            net_receivers[msg] = false
            if not this.suppress_warnings then
              printJson(([=[[
                "",
                {"text":"[warning] ", "color":"#FFDD55"},
                "%s",
                {"text":" : server attempted to send message '%s', but it is not in the registry\n", "color":"#FFDD55"}
              ]]=]):format(avatar:getEntityName(), msg))
            end
          end
        end
      end
    end

    if found and client.getTextWidth(json) == 0 then
      --print(avatar:getCurrentInstructions())
      return false
    end
  end, "GSServerNet:ReceiveMessage_ChatHandler")


  ---===|| TIMEOUT ||==============================================================================================---

  events.TICK:register(function()
    local time = world.getTime() - this.timeout
    for i = #trigger_queue, 1, -1 do
      local message = trigger_queue[i]
      if message.time <= time then
        message.resolved = true
        message.err = "message timed out"
        if message.timeout_action ~= nil then
          if message.timeout_action then
            if message.success then message.success(message.name) end
          else
            if message.error then message.error(message.name, "message timed out") end
          end
        elseif this.timeout_errors then
          if message.error then message.error(message.name, "message timed out") end
        else
          if message.success then message.success(message.name) end
        end
        remove(trigger_queue, i)
      end
    end
  end, "GSServerNet:Tick_Timeout")


  ---===|| INTERNAL ||=============================================================================================---

  -- Grouping all of this in here because it's already in a HOST block.

  trigger_queue[1] = setmetatable({
    name = "_start_",
    resolved = false,
    time = world.getTime(),
    timeout_action = false,
    success = function()
      -- Report success to all awaiting functions.
      server_responded = true
      for _, func in ipairs(awaiting_response) do func(true) end
      awaiting_response = nil

      pings["GS$SVNet"](true)
    end,
    error = function()
      -- Report failure to all awaiting functions.
      server_responded = false
      for _, func in ipairs(awaiting_response) do func(false) end
      awaiting_response = nil

      pings["GS$SVNet"](false)

      -- Stop the server from sending a registry after failure.
      net_receivers._registry_ = function() end

      -- Report failure to all awaiting registry functions.
      server_gotregistry = false
      for _, func in ipairs(awaiting_registry) do func(false) end
      awaiting_registry = nil
    end
  }, MessageMT)
  host:sendChatCommand("/trigger svnet._start_ set 1")

  ---@param _ string
  ---@param version number
  ---@param receive string[]
  ---@param send string[]
  net_receivers._registry_ = function(_, version, receive, send)
    if type(version) == "table" then version, receive, send = 0, version, receive end
    if type(receive) ~= "table" or type(send) ~= "table" then return end
    local not_found = {}

    local show_warnings = not this.suppress_warnings

    if show_warnings and version ~= PROTOCOL then
      printJson(([=[[
        "",
        {"text": "[warning] ", "color":"#FFDD55"},
        "%s",
        {"text": " : client's protocol version (%d) does not match server's (%d)", "color":"#FFDD55"}
      ]]=]):format(avatar:getEntityName(), PROTOCOL, version))
    end

    -- If `_start_` is timing out, don't let it error from that.
    local start = trigger_queue[1]
    if start and start.name == "_start_" then start.timeout_action = true end

    local reg_send = this.registry.send
    for _, name in ipairs(send) do
      if type(name) == "string" then
        name = name:gsub("^svnet[.:]", "")
        if name:match("^[%w_.+-][%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?[%w_.+-]?$") then
          insert(reg_send, name)
          reg_send[name] = true
        end
      end
    end

    local reg_receive = this.registry.receive
    for _, name in ipairs(receive) do
      if type(name) == "string" then
        name = name:gsub("^svnet[.:]", "")
        if name:match("^[%w_./-]+$") then
          if show_warnings and not net_receivers[name] then
            net_receivers[name] = false
            insert(not_found, name)
          end

          insert(reg_receive, name)
          reg_receive[name] = true
        end
      end
    end

    if show_warnings and #not_found > 0 then
      local svnet_comp = [[
        {
          "text": "svnet:%s",
          "color": "gold",
          "hoverEvent": {
            "action": "show_text",
            "contents": [
              "",
              {"text": "How to define this receiver:\n", "underline": true, "bold": true},

              {"text": "local ", "color": "#569CD6"}, {"text": "SVNet", "color": "#9CDCFE"}, " = ",
              {"text": "require", "color": "#DCDCAA"}, "(", {"text": "\"%s\"", "color": "#CE9178"}, ")\n\n",

              {"text": "SVNet", "color": "#9CDCFE"}, ".", {"text": "receive", "color": "#DCDCAA"}, "(",
              {"text": "\"%s\"", "color": "#CE9178"}, ", ", {"text": "function", "color": "#C586C0"}, "(",
              {"text": "name", "color": "#9CDCFE"}, ", ", {"text": "param1", "color": "#9CDCFE"}, ", ",
              {"text": "param2", "color": "#9CDCFE"}, ",  … )\n",

              {"text": "  -- Do stuff here\n", "color": "#6A9955"},

              {"text": "end", "color": "#C586C0"}, ")"
            ]
          }
        }
      ]]
      local svnet_separator = [[,{"text":"], [", "color": "gray"},]]

      local components = {}

      table.sort(not_found)
      for i, name in ipairs(not_found) do
        components[i] = svnet_comp:format(name, FULL_PATH, name)
      end

      printJson(([=[[
        "",
        {"text": "[warning] ", "color":"#FFDD55"},
        "%s",
        {"text": " : client is missing message recievers for messages defined in the server's registry\nThe following recievers are missing: ", "color":"#FFDD55"},
        {"text":"[", "color": "gray"},
        %s,
        {"text":"]\n", "color": "gray"}
      ]]=]):format(avatar:getEntityName(), table.concat(components, svnet_separator)))
    end

    -- Stop the server from sending another registry.
    net_receivers._registry_ = function() end

    -- Send the registry to all awaiting functions
    local reg = this.registry
    server_gotregistry = true
    for _, func in ipairs(awaiting_registry) do func(reg) end
    awaiting_registry = nil
  end
end


---===|| CONNECTION PING ||==========================================================================================---

-- HOST does not run this as it is too unreliable.

pings["GS$SVNet"] = function(success)
  if not awaiting_response or HOST then return end
  server_responded = success
  for _, func in ipairs(awaiting_response) do func(success) end
  awaiting_response = nil
end


---===|| END ||======================================================================================================---

return setmetatable(this, thismt)
